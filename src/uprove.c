/**
 * uprove.c
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope t_ it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright (C) Wojciech Mostowski, Radboud University Nijmegen, April 2011.
 * Copyright (C) Pim Vullers, Radboud University Nijmegen, April 2012.
 */

// Name everything "uprove"
#pragma attribute("aid", "75 70 72 6F 76 65")
#pragma attribute("dir", "61 10 4f 6 75 70 72 6F 76 65 50 6 75 70 72 6F 76 65")

#include <multosarith.h>
#include <multoscomms.h>
#include <multoscrypto.h>
#include <string.h>

#include "defs_apdu.h"
#include "defs_sizes.h"
#include "defs_types.h"
#include "funcs_debug.h"
#include "math.h"

#pragma melpublic

union {
  unsigned char number_p_size[PSIZE_BYTES];    // a sizeof(P) number
  unsigned char number_q_size[QSIZE_BYTES];    // a sizeof(Q) number
  unsigned char D_data[MAX_ATTR];              // selection of D
  unsigned char raw_data[255];
} apdu_data;

// First things that are defo static (==> E2PROM)

#pragma melstatic

// The fixed values are from the U-Porve Cryptographic Specification V1.0
// to ease testing

NUMBER_PSIZE p = {
    0x00,
    0xd2, 0x1a, 0xe8, 0xd6, 0x6e, 0x6c, 0x6b, 0x3c, 0xed, 0x0e, 0xb3, 0xdf, 0x1a, 0x26, 0xc9, 0x1b, 0xde, 0xed, 0x01, 0x3c, 0x17, 0xd8, 0x49, 0xd3, 0x0e, 0xc3, 0x09, 0x81, 0x3e, 0x4d, 0x37, 0x99,
    0xf2, 0x6d, 0xb0, 0xd4, 0x94, 0xe8, 0x2e, 0xc6, 0x1e, 0xa9, 0xfd, 0xc7, 0x0b, 0xb5, 0xcb, 0xca, 0xf2, 0xe5, 0xf1, 0x8a, 0x83, 0x64, 0x94, 0xf5, 0x8e, 0x67, 0xc6, 0xd6, 0x16, 0x48, 0x0c, 0x37,
    0xa7, 0xf2, 0x30, 0x61, 0x01, 0xfc, 0x9f, 0x0f, 0x47, 0x68, 0xf9, 0xc9, 0x79, 0x3c, 0x2b, 0xe1, 0x76, 0xb0, 0xb7, 0xc9, 0x79, 0xb4, 0x06, 0x5d, 0x3e, 0x83, 0x56, 0x86, 0xa3, 0xf0, 0xb8, 0x42,
    0x0c, 0x68, 0x34, 0xcb, 0x17, 0x93, 0x03, 0x86, 0xde, 0xda, 0xb2, 0xb0, 0x7d, 0xd4, 0x73, 0x44, 0x9a, 0x48, 0xba, 0xab, 0x31, 0x62, 0x86, 0xb4, 0x21, 0x05, 0x24, 0x75, 0xd1, 0x34, 0xcd, 0x3b
};

NUMBER_PSIZE g = {
    0x00, 
    0xab, 0xce, 0xc9, 0x72, 0xe9, 0xa9, 0xdd, 0x8d, 0x13, 0x32, 0x70, 0xcf, 0xea, 0xc2, 0x6f, 0x72, 0x6e, 0x56, 0x7d, 0x96, 0x47, 0x57, 0x63, 0x0d, 0x6b, 0xd4, 0x34, 0x60, 0xd0, 0x92, 0x3a, 0x46,
    0xae, 0xc0, 0xac, 0xe2, 0x55, 0xeb, 0xf3, 0xdd, 0xd4, 0xb1, 0xc4, 0x26, 0x4f, 0x53, 0xe6, 0x8b, 0x36, 0x1a, 0xfb, 0x77, 0x7a, 0x13, 0xcf, 0x00, 0x67, 0xda, 0xe3, 0x64, 0xa3, 0x4d, 0x55, 0xa0,
    0x96, 0x5a, 0x6c, 0xcc, 0xf7, 0x88, 0x52, 0x78, 0x29, 0x23, 0x81, 0x3c, 0xf8, 0x70, 0x88, 0x34, 0xd9, 0x1f, 0x65, 0x57, 0xd7, 0x83, 0xec, 0x75, 0xb5, 0xf3, 0x7c, 0xd9, 0x18, 0x5f, 0x02, 0x7b,
    0x04, 0x2c, 0x1c, 0x72, 0xe1, 0x21, 0xb1, 0x26, 0x6a, 0x40, 0x8b, 0xe0, 0xbb, 0x72, 0x70, 0xd6, 0x59, 0x17, 0xb6, 0x90, 0x83, 0x63, 0x3e, 0x1f, 0x3c, 0xd6, 0x06, 0x24, 0x61, 0x2f, 0xc8, 0xc1
};

NUMBER_QSIZE q = { 0x00, 0xff, 0xf8, 0x0a, 0xe1, 0x9d, 0xae, 0xbc, 0x61, 0xf4, 0x63, 0x56, 0xaf, 0x09, 0x35, 0xdc, 0x0e, 0x81, 0x14, 0x8e, 0xb1 };

NUMBER_QSIZE q_minus_2 = { 0x00, 0xff, 0xf8, 0x0a, 0xe1, 0x9d, 0xae, 0xbc, 0x61, 0xf4, 0x63, 0x56, 0xaf, 0x09, 0x35, 0xdc, 0x0e, 0x81, 0x14, 0x8e, 0xaf };

unsigned char TI[] = "Token information field value";

unsigned char PI[] = "Prover information field value";

unsigned char UID_p[255] = { 0x49, 0x73, 0x73, 0x75, 0x65, 0x72, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x20, 0x55, 0x49, 0x44 };
int UID_p_length = 21;

unsigned char UID_H[] = "SHA-1";

unsigned char S[] = "Issuer parameters specification";

char rcounter = 0;

NUMBER_PSIZE g_i[MAX_ATTR + 2] = { // i = 0,...,n,t
    // default test vectors
    // g0
    0x00,
    0x9c, 0x98, 0xc1, 0x77, 0xf8, 0xcc, 0x79, 0x9d, 0x67, 0xcf, 0x2b, 0xed, 0x45, 0x6a, 0xb4, 0x5b, 0xd8, 0x94, 0xae, 0x94, 0xd3, 0x04, 0x33, 0x4b, 0x5e, 0xe3, 0x83, 0xcc, 0x7c, 0x76, 0x6e, 0xb4,
    0xbc, 0xcd, 0x7e, 0x5f, 0x22, 0xd2, 0xf2, 0x22, 0xac, 0x46, 0x64, 0x1f, 0x1f, 0x4e, 0xef, 0x09, 0x28, 0xc7, 0x61, 0x3e, 0x45, 0x8a, 0x97, 0xfd, 0x71, 0xe3, 0x22, 0x55, 0x06, 0x6c, 0xcc, 0x71,
    0x28, 0x8f, 0x4c, 0x66, 0x4b, 0xde, 0x15, 0x5b, 0xc5, 0x62, 0xa6, 0x11, 0xf6, 0xba, 0xe7, 0x66, 0xe1, 0x64, 0x5a, 0x55, 0x1e, 0x32, 0x1f, 0x93, 0x4e, 0xa9, 0xca, 0x4f, 0x92, 0xed, 0xe7, 0xd8,
    0xbb, 0x56, 0x86, 0x03, 0x78, 0xfb, 0x6a, 0x85, 0x00, 0xdb, 0x50, 0x8f, 0x9b, 0x53, 0x32, 0x12, 0x90, 0xf4, 0x86, 0x6d, 0x5a, 0x71, 0xe2, 0x9b, 0xda, 0x80, 0xbe, 0xd7, 0x9c, 0xa9, 0x0d, 0x19,
#if MAX_ATTR > 0
    // g1
    0x00,
    0x52, 0x83, 0xa1, 0xef, 0xa6, 0x02, 0x6c, 0xf1, 0x92, 0x04, 0x0f, 0xbe, 0xb7, 0x22, 0x21, 0xb7, 0x4a, 0xa8, 0x81, 0xba, 0xcd, 0x36, 0x42, 0xc0, 0x7e, 0x1c, 0x98, 0xb9, 0x9b, 0x3c, 0xeb, 0x8c,
    0x4b, 0x3c, 0x19, 0x2e, 0x87, 0x56, 0x8f, 0xb2, 0x8c, 0x37, 0x4a, 0x02, 0x3c, 0x8f, 0xff, 0x46, 0x03, 0xd9, 0x90, 0x65, 0x27, 0x81, 0x66, 0x84, 0x5c, 0xbd, 0x9f, 0x1f, 0x31, 0x25, 0xc2, 0x29,
    0xf7, 0x8a, 0x84, 0x9c, 0x54, 0x1b, 0xbf, 0x8a, 0x59, 0x1b, 0xd5, 0x85, 0x30, 0xd3, 0xf0, 0x90, 0x37, 0x88, 0x8f, 0x57, 0xb0, 0x5f, 0x6f, 0x30, 0x14, 0x9b, 0xf0, 0x41, 0x38, 0x01, 0x3c, 0x94,
    0xfc, 0x62, 0xb9, 0xa5, 0xe2, 0xe1, 0xd0, 0xa0, 0xd8, 0x14, 0x27, 0xf6, 0xab, 0xf6, 0x41, 0x2e, 0x1d, 0x49, 0xbf, 0xef, 0x65, 0xa2, 0x1f, 0x03, 0xcb, 0xab, 0x11, 0xd2, 0x97, 0x2d, 0x5b, 0xeb,
#endif
#if MAX_ATTR > 1
    // g2
    0x00,
    0x84, 0x35, 0xae, 0xa8, 0xed, 0x5d, 0x2c, 0x73, 0x5c, 0xf6, 0x54, 0x61, 0x04, 0x1d, 0x42, 0x39, 0xdf, 0xc6, 0x95, 0x0e, 0xbf, 0xff, 0x69, 0xca, 0x3b, 0xe8, 0xad, 0x40, 0x22, 0x40, 0xef, 0x10,
    0x87, 0x6f, 0xf1, 0x02, 0x4c, 0x98, 0xf9, 0x66, 0x73, 0xb0, 0x47, 0x70, 0xe3, 0x3a, 0xcf, 0x90, 0x95, 0xe9, 0x2c, 0x48, 0x38, 0x03, 0x23, 0x14, 0x2a, 0xa3, 0xfe, 0xd9, 0xe1, 0x1e, 0xac, 0xf8,
    0x03, 0xcf, 0x34, 0x77, 0xd6, 0x32, 0xaf, 0xb2, 0x15, 0x4c, 0x80, 0x19, 0xb0, 0x55, 0x99, 0xd4, 0x79, 0x74, 0x8d, 0x7a, 0x12, 0xad, 0x06, 0x72, 0x6e, 0x58, 0xdb, 0x12, 0xa0, 0xfa, 0xcc, 0xd3,
    0xcd, 0x8d, 0xed, 0x7a, 0x43, 0x92, 0xd6, 0xf5, 0x20, 0xdc, 0x72, 0x3f, 0x06, 0x73, 0xd9, 0xc4, 0x35, 0xc4, 0xea, 0x13, 0xad, 0x3b, 0xa8, 0x0d, 0x7c, 0x0f, 0x13, 0x2d, 0xd3, 0x2b, 0x2b, 0x24,
#endif
#if MAX_ATTR > 2
    // g3
    0x00,
    0xa0, 0x9a, 0x89, 0xf9, 0xad, 0x13, 0x7f, 0x59, 0x47, 0xa7, 0x5e, 0x46, 0xb6, 0x60, 0x9c, 0x25, 0xd4, 0xea, 0x5f, 0x45, 0x4c, 0x86, 0x2a, 0x5a, 0x5e, 0x63, 0x1e, 0x93, 0xfb, 0x3a, 0x71, 0xd0,
    0x12, 0xfb, 0x04, 0x24, 0xec, 0xe3, 0x66, 0x78, 0x17, 0x27, 0x90, 0x9e, 0x75, 0x83, 0x82, 0x1c, 0x6d, 0x82, 0xc4, 0x8e, 0x00, 0x42, 0xc3, 0x33, 0xd0, 0x40, 0x24, 0xe6, 0xf9, 0x1f, 0x0e, 0x07,
    0x61, 0xdc, 0x8c, 0x64, 0xc9, 0x16, 0x7f, 0x39, 0x5a, 0x75, 0xef, 0x74, 0xee, 0x27, 0x04, 0xe4, 0x07, 0x19, 0xe7, 0x05, 0x72, 0xc3, 0xc8, 0xb5, 0x62, 0xf3, 0x1a, 0xb7, 0x87, 0x70, 0x6a, 0xa1,
    0x3f, 0xfa, 0x49, 0x52, 0x1b, 0x49, 0x62, 0xc5, 0xe7, 0xcd, 0x83, 0x6b, 0x06, 0x38, 0xa3, 0x8c, 0x63, 0xd0, 0x87, 0x89, 0xff, 0xfc, 0xe0, 0x96, 0xd8, 0xd6, 0x87, 0xbb, 0x45, 0x1d, 0xdc, 0x9f,
#endif
#if MAX_ATTR > 3
    // g4
    0x00,
    0x5a, 0x31, 0x08, 0xff, 0xb5, 0xeb, 0xa3, 0x55, 0x05, 0xb0, 0x95, 0xd8, 0xdc, 0xdb, 0x44, 0x59, 0x4a, 0x33, 0xff, 0xf8, 0xc5, 0xa5, 0x5f, 0xcc, 0x3e, 0x34, 0x20, 0x4a, 0x15, 0x92, 0x64, 0x42,
    0x08, 0xe6, 0x75, 0x0d, 0x88, 0x92, 0x18, 0x5a, 0x04, 0xbc, 0xea, 0xff, 0x55, 0xdd, 0xf5, 0x24, 0xaf, 0xba, 0x84, 0x6d, 0x9b, 0xff, 0x87, 0x67, 0xf3, 0xa0, 0xd7, 0xb7, 0xde, 0xf0, 0x11, 0x44,
    0xdf, 0xa7, 0xa8, 0x40, 0x58, 0x20, 0xba, 0x86, 0x43, 0x02, 0xfd, 0x04, 0xf9, 0x39, 0x64, 0xca, 0xf8, 0xd0, 0xd4, 0x66, 0x08, 0xa7, 0xcb, 0xdd, 0x0a, 0x73, 0x76, 0x8f, 0x8c, 0x2f, 0xb5, 0x76,
    0xf4, 0x4d, 0x21, 0xbe, 0x29, 0x1c, 0x80, 0x1f, 0x02, 0xd6, 0xa4, 0x1d, 0x1e, 0x9d, 0xed, 0xaa, 0x25, 0x84, 0x23, 0xa5, 0x3a, 0xc5, 0x18, 0xa3, 0xee, 0x76, 0xe4, 0xf9, 0x2e, 0xed, 0x34, 0xb1,
#endif
#if MAX_ATTR > 4
    // g5
    0x00,
    0x38, 0x0d, 0xb7, 0xb7, 0x69, 0xc3, 0xe7, 0x33, 0xce, 0xd6, 0x0e, 0xe1, 0x81, 0xaf, 0x58, 0x7e, 0x25, 0x54, 0xcc, 0x8c, 0x7a, 0x97, 0xa9, 0x93, 0x67, 0xa6, 0x13, 0xff, 0x26, 0xd8, 0x8d, 0xeb,
    0xbc, 0xa3, 0x94, 0x8c, 0x6a, 0xc2, 0x43, 0x9b, 0x3d, 0xa5, 0x20, 0xad, 0x6c, 0x58, 0x86, 0x50, 0x12, 0xee, 0xbe, 0xdb, 0xf9, 0x6c, 0x73, 0x92, 0x15, 0xb5, 0xab, 0x20, 0x11, 0xd6, 0xa6, 0x3b,
    0x85, 0xfc, 0x9c, 0x7a, 0xca, 0x09, 0x8c, 0x17, 0x2d, 0xde, 0x7e, 0xaf, 0x01, 0xb7, 0x02, 0x83, 0x17, 0x07, 0x8d, 0x65, 0x90, 0x48, 0x82, 0x48, 0x2c, 0xa1, 0x3f, 0x14, 0xe2, 0xb2, 0xad, 0x0c,
    0xd7, 0xed, 0x80, 0x18, 0x4f, 0x73, 0x37, 0xf9, 0xa1, 0xac, 0xb7, 0x98, 0x43, 0xef, 0x98, 0xb8, 0x78, 0x24, 0x98, 0x4d, 0x2f, 0x83, 0xb6, 0x4e, 0x58, 0x68, 0xa3, 0x49, 0x20, 0x46, 0x01, 0x65,
#endif
    // gt
    0x00,
    0x06, 0x61, 0xa8, 0x57, 0xea, 0x4b, 0x1c, 0xbb, 0x0b, 0x8f, 0xb3, 0x5a, 0x4a, 0xe3, 0x30, 0x12, 0x34, 0xa9, 0x93, 0xe4, 0x97, 0xee, 0x06, 0xb0, 0x6a, 0x13, 0x00, 0xe8, 0xfc, 0xf6, 0x56, 0x51,
    0xb1, 0x09, 0x33, 0x05, 0xae, 0xa1, 0x26, 0x29, 0xe7, 0x80, 0x80, 0x75, 0x06, 0x37, 0xe4, 0xa6, 0xb7, 0xc9, 0xf2, 0x16, 0xb2, 0xe9, 0x45, 0x5b, 0x45, 0x8f, 0x73, 0x6b, 0x8f, 0x74, 0x73, 0x7b,
    0xab, 0x17, 0x9b, 0xba, 0xa1, 0x86, 0x77, 0x33, 0x45, 0xce, 0xf1, 0xdd, 0x48, 0x16, 0x18, 0xaf, 0x67, 0x14, 0x0c, 0x0a, 0x21, 0x04, 0x54, 0x8b, 0x25, 0x71, 0x6f, 0x11, 0x10, 0x04, 0xd8, 0xc5,
    0xd2, 0x51, 0x77, 0x75, 0x91, 0xdd, 0xe4, 0x42, 0xbc, 0xdb, 0xca, 0x62, 0x52, 0xbd, 0x5a, 0x77, 0xc7, 0xf7, 0x6e, 0x7e, 0x33, 0x79, 0x16, 0x3e, 0xba, 0x0e, 0xb4, 0x9b, 0xf8, 0x9c, 0xc3, 0xad
};

NUMBER_PSIZE z_i[MAX_ATTR + 2] = { // i = 0,...,n,t
    // z0:
    0x00,
    0x0a, 0x4d, 0x1c, 0xde, 0xe0, 0xab, 0xb7, 0x89, 0x47, 0xc0, 0xd5, 0x7c, 0xce, 0x5b, 0x26, 0x54, 0x01, 0x48, 0x52, 0x53, 0x18, 0x0d, 0x3e, 0x8d, 0x1f, 0xec, 0xa7, 0x32, 0x5e, 0xe1, 0x37, 0x5b,
	0xf3, 0x87, 0xbd, 0xa7, 0x3b, 0x84, 0x64, 0x5b, 0xb0, 0x09, 0xfb, 0x8c, 0xbf, 0x43, 0x1a, 0x21, 0x3e, 0x74, 0x36, 0x2c, 0xde, 0xc8, 0x55, 0xcf, 0x62, 0x19, 0x23, 0xed, 0x0b, 0x5d, 0x22, 0x84,
	0x63, 0xe8, 0x09, 0xee, 0x80, 0x88, 0xe2, 0x4c, 0xac, 0xf3, 0x72, 0x60, 0xa5, 0x8a, 0x83, 0x45, 0xfb, 0x53, 0xd3, 0xb9, 0x2d, 0x43, 0x0a, 0x83, 0x81, 0xf3, 0x99, 0x33, 0xc8, 0x57, 0xe1, 0xd8,
	0xfe, 0x22, 0x99, 0x51, 0xd1, 0x8b, 0xe6, 0xf4, 0x8a, 0x89, 0x1f, 0x29, 0xb1, 0xf0, 0xf9, 0xa4, 0xb3, 0xfa, 0xa2, 0x65, 0xf3, 0x8e, 0x48, 0x50, 0xad, 0x9d, 0x0a, 0x59, 0xbc, 0xe8, 0xc7, 0x2b,
#if MAX_ATTR > 0
    // z1:
    0x00,
    0x89, 0x08, 0xc9, 0xcb, 0xe4, 0xb5, 0xee, 0x5c, 0xe9, 0x52, 0xa7, 0xf0, 0x4d, 0xc4, 0xfe, 0xfe, 0x65, 0xb0, 0xe6, 0x04, 0xd6, 0xf1, 0xdf, 0x45, 0xe1, 0xf4, 0x44, 0x73, 0xb7, 0x5a, 0xa7, 0xe1,
	0x93, 0x5a, 0x88, 0x77, 0x2c, 0x26, 0x63, 0x86, 0xb8, 0x52, 0x02, 0x33, 0xf9, 0x8c, 0x80, 0xaa, 0x26, 0xf8, 0x61, 0x72, 0x67, 0xd6, 0x6a, 0x29, 0xed, 0xff, 0x3a, 0x92, 0x2e, 0xa2, 0x8d, 0x54,
	0x4b, 0x93, 0xbc, 0xbc, 0x80, 0xfd, 0xb1, 0x96, 0xd9, 0x67, 0x75, 0x53, 0xed, 0x1f, 0xe4, 0x1e, 0x36, 0xd7, 0x9d, 0xd5, 0x3f, 0x45, 0x53, 0x73, 0xab, 0x8c, 0xf1, 0x26, 0x23, 0x02, 0x40, 0xaf,
	0xeb, 0xec, 0x48, 0x67, 0xd1, 0x81, 0xe3, 0xdd, 0xef, 0xd7, 0xb5, 0x83, 0x2b, 0xda, 0x1d, 0x85, 0x8e, 0x6e, 0xe4, 0xbb, 0x52, 0xa7, 0x77, 0x29, 0x06, 0x64, 0x8f, 0xd8, 0x83, 0x69, 0x7f, 0x81,
#endif
#if MAX_ATTR > 1
    // z2:
    0x00,
    0x55, 0x33, 0x06, 0xf7, 0xbb, 0x76, 0x4b, 0x7c, 0xb9, 0xf2, 0x9c, 0xd8, 0x97, 0xb1, 0xc2, 0xb1, 0xce, 0x9a, 0x38, 0x86, 0x72, 0x0a, 0xc5, 0x62, 0xa2, 0x12, 0xd7, 0xba, 0x00, 0x86, 0x76, 0x7a,
	0x5a, 0x1d, 0xa2, 0x95, 0xd9, 0x92, 0x12, 0x56, 0x67, 0xcd, 0xd3, 0x6b, 0x39, 0x2f, 0x00, 0x9c, 0xb7, 0xd7, 0x40, 0xee, 0x08, 0x36, 0x41, 0xd0, 0x46, 0xc7, 0xd3, 0xe6, 0xe5, 0x5d, 0x0b, 0xd4,
	0x48, 0x42, 0x80, 0xeb, 0x57, 0x80, 0xe0, 0x81, 0x19, 0x3a, 0x57, 0xfa, 0xb1, 0x71, 0x2a, 0xfd, 0x28, 0x3b, 0x71, 0x72, 0xd0, 0x42, 0x4a, 0xba, 0x82, 0x66, 0x80, 0x3c, 0x99, 0x3b, 0xc5, 0x85,
	0x53, 0x94, 0xf6, 0xe4, 0x53, 0x95, 0x6a, 0x63, 0x38, 0xe5, 0xb6, 0xe3, 0x5f, 0x45, 0x98, 0x48, 0x7d, 0xfd, 0x97, 0xfb, 0x8e, 0x11, 0x61, 0xca, 0x94, 0x8b, 0x34, 0xb4, 0x9d, 0x87, 0x11, 0xc6,
#endif
#if MAX_ATTR > 2
    // z3:
    0x00,
    0xa8, 0x0e, 0xe5, 0x90, 0x33, 0xb0, 0x9c, 0x23, 0xe2, 0xe5, 0x85, 0x3f, 0xf4, 0x94, 0x71, 0xa7, 0x5c, 0xa1, 0x75, 0x08, 0xdf, 0x20, 0x43, 0x16, 0xc7, 0x28, 0x21, 0x06, 0x6a, 0x40, 0x9a, 0x13,
	0x5e, 0xc7, 0xc6, 0x2d, 0x18, 0xa2, 0x78, 0xd3, 0x6e, 0x11, 0x71, 0x2c, 0x97, 0x4d, 0x4d, 0xb8, 0xd6, 0xeb, 0x21, 0x1e, 0x4f, 0xb0, 0xc2, 0x3a, 0x17, 0x02, 0x77, 0x65, 0x95, 0x90, 0xda, 0xd9,
	0x6a, 0x8c, 0x89, 0x01, 0x7e, 0x9b, 0xbc, 0x09, 0x74, 0x6d, 0x6c, 0x35, 0x59, 0xa3, 0xc4, 0x21, 0x26, 0x7f, 0xd2, 0x1f, 0x64, 0x89, 0x1a, 0xb6, 0xeb, 0xb2, 0x04, 0x1f, 0x68, 0x2d, 0xa1, 0xf5,
	0x42, 0xa3, 0xb4, 0x0d, 0x86, 0xba, 0xbf, 0xdf, 0xaa, 0x21, 0xc9, 0xc4, 0x00, 0xd4, 0xda, 0x7d, 0x3f, 0x2d, 0xaf, 0xdf, 0x3d, 0x12, 0x54, 0xb1, 0x11, 0xbd, 0xdf, 0x9b, 0x94, 0xec, 0xb3, 0xfd,
#endif
#if MAX_ATTR > 3
    // z4:
    0x00,
	0xce, 0x00, 0x34, 0xbb, 0x53, 0xf8, 0xed, 0xde, 0x7a, 0x6d, 0x36, 0x0c, 0x1d, 0x88, 0xfb, 0x46, 0xa5, 0x1a, 0x41, 0xad, 0x0e, 0x41, 0xc2, 0x45, 0x29, 0xf6, 0xde, 0xce, 0x72, 0xa2, 0xcd, 0xbd,
	0x3c, 0x38, 0x01, 0xab, 0x33, 0x55, 0xc8, 0xba, 0x4e, 0xde, 0x40, 0x12, 0x2c, 0xf2, 0x9a, 0x68, 0xf3, 0x7c, 0xbc, 0x78, 0xcf, 0xaf, 0x68, 0x79, 0x1b, 0x82, 0x22, 0x8e, 0x3d, 0x55, 0x93, 0x2e,
	0x2c, 0xda, 0x82, 0x68, 0x21, 0x4c, 0x5b, 0x82, 0x9a, 0x91, 0x3e, 0x8c, 0xbb, 0x98, 0x6a, 0x51, 0x55, 0xeb, 0xfa, 0x52, 0x37, 0x5c, 0x14, 0x2f, 0x68, 0xd7, 0xde, 0x5d, 0xdd, 0x08, 0xb5, 0xd3,
	0x2f, 0x76, 0x13, 0x34, 0xb9, 0xc3, 0x6a, 0x74, 0xa8, 0xf7, 0xa1, 0x88, 0xb7, 0x8e, 0xc5, 0x91, 0x07, 0x01, 0x7a, 0x01, 0x54, 0x22, 0xe1, 0x86, 0xb7, 0xbf, 0x47, 0xc1, 0x22, 0x4b, 0x10, 0x1e,
#endif
#if MAX_ATTR > 4
    // z5:
    0x00,
    0x5f, 0xed, 0x08, 0xeb, 0x73, 0x0a, 0x69, 0x34, 0x95, 0xb0, 0x9d, 0x36, 0x19, 0x37, 0x49, 0x61, 0x25, 0x38, 0xe8, 0x41, 0x96, 0xad, 0x23, 0xad, 0x62, 0xc3, 0xe1, 0x5c, 0x51, 0xbe, 0x78, 0xb6,
	0x2d, 0x7f, 0x35, 0xd0, 0x38, 0xf4, 0x1d, 0xd5, 0x1a, 0x9b, 0x1a, 0x9a, 0x48, 0x00, 0xd0, 0x45, 0xe1, 0x05, 0x41, 0xc9, 0x06, 0x6c, 0x1c, 0xb9, 0x41, 0x11, 0xcc, 0xc1, 0xb6, 0x04, 0x3b, 0x58, 
	0xf2, 0xd1, 0x38, 0x1a, 0xdd, 0x8b, 0x90, 0x5f, 0x1c, 0x4b, 0xae, 0xfa, 0xab, 0x27, 0xf0, 0x1a, 0x0d, 0x66, 0x41, 0x24, 0xee, 0x3c, 0x86, 0xca, 0xb9, 0xc4, 0xee, 0xe7, 0xf0, 0x58, 0xa0, 0x98, 
	0x4f, 0xa2, 0x18, 0xc7, 0x16, 0x33, 0xc8, 0x61, 0xd7, 0xe3, 0x3a, 0x8f, 0x69, 0x19, 0x91, 0x22, 0x3f, 0x54, 0x77, 0x7c, 0xc5, 0xe5, 0x4e, 0x70, 0x23, 0x57, 0x16, 0x35, 0x68, 0x8b, 0x77, 0x2a,
#endif
    // zt:
    0x00,
    0xbf, 0xab, 0x41, 0xde, 0xbc, 0x7d, 0x75, 0x91, 0x82, 0x88, 0xf8, 0xa5, 0xa9, 0x5c, 0x19, 0xa3, 0x68, 0xd1, 0x98, 0x1d, 0xb1, 0x04, 0x43, 0x1d, 0x4d, 0xf9, 0xaf, 0x6f, 0x92, 0x94, 0x7f, 0x7f, 
	0x49, 0x33, 0x8c, 0xca, 0xe9, 0x1f, 0xbd, 0x9b, 0x13, 0xa3, 0x9b, 0x0c, 0xdb, 0xce, 0x02, 0x25, 0x83, 0xe8, 0xfc, 0x6f, 0xeb, 0x67, 0xd9, 0xc6, 0xd1, 0x89, 0x62, 0x55, 0xa5, 0x81, 0xbb, 0x80, 
	0x66, 0xcc, 0x89, 0x79, 0x4e, 0xb7, 0x3a, 0xdd, 0x8e, 0x96, 0x0b, 0xc0, 0xf8, 0x0e, 0x7e, 0xdf, 0x9c, 0x16, 0xb0, 0xa6, 0x13, 0x43, 0x14, 0x91, 0xf7, 0x0b, 0x11, 0x11, 0xc8, 0x6d, 0x08, 0x59, 
	0x8a, 0x91, 0x6c, 0xdd, 0xf8, 0xfb, 0x8b, 0x6c, 0x9b, 0xf0, 0xc8, 0x54, 0x10, 0x6a, 0x29, 0x53, 0xf6, 0xed, 0x32, 0x8c, 0x48, 0x0a, 0x03, 0xdd, 0x26, 0xde, 0x4f, 0xb1, 0x90, 0xa5, 0x93, 0x01
};

NUMBER_QSIZE x_i[MAX_ATTR + 1] = { // i = 1,...,n,t counting from 0
#if MAX_ATTR > 0
    // x1:
    0x00, 0x9c, 0xf4, 0xab, 0x0d, 0x76, 0xc4, 0xfe, 0x30, 0xe7, 0xb0, 0xc2, 0x85, 0x86, 0x83, 0xcc, 0x11, 0xa4, 0x0d, 0x6b, 0x95,
#endif
#if MAX_ATTR > 1
    // x2:
    0x00, 0x7f, 0xb7, 0x3a, 0xe5, 0x90, 0x6b, 0x37, 0x0b, 0x90, 0x92, 0x30, 0x24, 0xf9, 0x2e, 0xb5, 0xa2, 0x85, 0x26, 0x63, 0x11,
#endif
#if MAX_ATTR > 2
    // x3:
    0x00, 0x15, 0x47, 0x91, 0x4c, 0x42, 0xbb, 0xb2, 0x6c, 0x64, 0x74, 0xd9, 0x4b, 0xd6, 0xbf, 0xcf, 0x62, 0x43, 0x18, 0xc9, 0xfe,
#endif
#if MAX_ATTR > 3
    // x4:
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
#endif
#if MAX_ATTR > 4
    // x5:
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x96, 0x02, 0xd2,
#endif
    // xt:
    0x00, 0xc4, 0x30, 0x8f, 0xf1, 0x4c, 0xad, 0xbe, 0x9e, 0x0a, 0x12, 0x00, 0xb7, 0xf6, 0x64, 0x00, 0xce, 0x44, 0x71, 0xe7, 0x7f
    };

ATTRIBUTE A_i[MAX_ATTR] = { // i = 1, ..., n
#if MAX_ATTR > 0
   11,
   0x41, 0x6c, 0x69, 0x63, 0x65, 0x20, 0x53, 0x6d, 0x69, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
#endif
#if MAX_ATTR > 1
   2,
   0x57, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
#endif
#if MAX_ATTR > 2
   18,
   0x31, 0x30, 0x31, 0x30, 0x20, 0x43, 0x72, 0x79, 0x70, 0x74, 0x6f, 0x20, 0x53, 0x74, 0x72, 0x65,
   0x65, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
#endif
#if MAX_ATTR > 3
   1,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
#endif
#if MAX_ATTR > 4
   4,
   0x49, 0x96, 0x02, 0xd2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#endif
   };	

unsigned char e_i[MAX_ATTR] = { 
#if MAX_ATTR > 0
0x01, 
#endif
#if MAX_ATTR > 1
0x01, 
#endif
#if MAX_ATTR > 2
0x01,
#endif
#if MAX_ATTR > 3
0x00,
#endif
#if MAX_ATTR > 4
0x00
#endif
};
  
NUMBER_PSIZE gamma = {
    0x00,
    0x65, 0x31, 0xf1, 0x8e, 0xaa, 0xaa, 0x03, 0xcc, 0x9a, 0xee, 0x63, 0xab, 0x9e, 0x73, 0xf4, 0x0f, 0x2e, 0x36, 0xf1, 0xec, 0xa0, 0x89, 0x7d, 0xdc, 0x2c, 0xd2, 0x24, 0x12, 0xd9, 0x90, 0x2f, 0x30,
	0xcc, 0xaf, 0x54, 0x24, 0x05, 0xe7, 0xe1, 0x6d, 0x7f, 0x17, 0x8b, 0x6f, 0x1a, 0x68, 0x7c, 0x0a, 0xa2, 0x24, 0xd6, 0x95, 0x41, 0x48, 0xa6, 0xd7, 0x18, 0xdb, 0xe9, 0xa1, 0x03, 0x67, 0x46, 0x50,
	0x9f, 0x5d, 0xcb, 0xb3, 0xea, 0xea, 0xca, 0xef, 0x74, 0xe7, 0x6c, 0xa0, 0x48, 0x85, 0xb5, 0x0c, 0x7e, 0x3f, 0x9b, 0x91, 0x35, 0xc5, 0xfc, 0xfa, 0x96, 0xf6, 0x1a, 0x57, 0x9e, 0x60, 0xd3, 0xcd,
	0x84, 0x97, 0xd0, 0x2b, 0x01, 0x8c, 0x29, 0x5c, 0x93, 0x55, 0xfb, 0x7c, 0xe7, 0xf8, 0xb7, 0xdc, 0x61, 0xbb, 0x78, 0xb2, 0xe9, 0xe0, 0x4d, 0x51, 0xff, 0x88, 0xab, 0xed, 0x11, 0x0c, 0x6e, 0xbe
};

NUMBER_PSIZE sigma_z = {
    0x00,
    0x7a, 0xc6, 0xe2, 0x29, 0x96, 0xbe, 0xf2, 0x25, 0x1f, 0x62, 0x7c, 0x7c, 0x8d, 0x9b, 0xe2, 0x9b, 0x2e, 0x35, 0x5b, 0xfb, 0xeb, 0x92, 0xbf, 0x1e, 0x01, 0x23, 0x80, 0x59, 0x2b, 0x24, 0x14, 0xb2, 
	0x4e, 0xef, 0x3c, 0xb4, 0x96, 0x93, 0xcf, 0x6c, 0xe8, 0x28, 0xeb, 0x5f, 0xaa, 0x94, 0xb1, 0xfa, 0xad, 0x18, 0x98, 0x17, 0xbd, 0xcb, 0x42, 0xd9, 0xfd, 0x28, 0xf1, 0x23, 0xfd, 0xdd, 0x03, 0xa7,
	0xb3, 0xe8, 0x3f, 0x9a, 0x4d, 0xa3, 0x07, 0x3b, 0x30, 0x10, 0x3d, 0xfa, 0x1d, 0xf5, 0x36, 0x75, 0xda, 0x51, 0xdf, 0xf9, 0x81, 0x3b, 0xab, 0x68, 0x0d, 0xb9, 0xc4, 0x86, 0x8d, 0xba, 0x6f, 0x48, 
	0x98, 0x24, 0x7b, 0x85, 0xd0, 0xfb, 0x09, 0x64, 0x69, 0x16, 0x05, 0x66, 0xfa, 0xbe, 0x2a, 0x85, 0x7a, 0xe2, 0xc0, 0x04, 0xab, 0xb6, 0x38, 0xf6, 0x69, 0xde, 0x1a, 0x6b, 0x6e, 0x22, 0xcf, 0xb4
};

// Since alpha, beta1, and beta2 are random in the protocol and there are no 
// APDUs to set them, we need remember the test values:

NUMBER_QSIZE alphaTest = { 0x00, 0xfe, 0x33, 0xd9, 0x54, 0x01, 0x9e, 0x2d, 0xf6, 0xba, 0x53, 0x9f, 0x4b, 0x28, 0x22, 0x92, 0x7c, 0x0a, 0x49, 0xb6, 0x61 };
NUMBER_QSIZE beta1Test = { 0x00, 0xc2, 0xc0, 0xbc, 0xf3, 0x00, 0xcf, 0xa5, 0x57, 0x74, 0x42, 0x92, 0x98, 0x04, 0xf3, 0xf7, 0xe6, 0x09, 0x3f, 0x6f, 0xea };
NUMBER_QSIZE beta2Test = { 0x00, 0x12, 0xd0, 0x62, 0xd3, 0xb2, 0xe1, 0xc5, 0xc2, 0x87, 0xa6, 0x22, 0xa0, 0xc4, 0x46, 0xb2, 0xf5, 0x9e, 0x23, 0x49, 0x2b };

int testMode = 1; // 1 - true, 0 - false

NUMBER_QSIZE alphaInverse = { 0x00, 0x56, 0xd8, 0x2b, 0x85, 0x9a, 0xb3, 0xd6, 0xdf, 0xe3, 0xbf, 0xb0, 0x60, 0x11, 0xee, 0xa4, 0x75, 0x0f, 0x62, 0x91, 0xcd };

NUMBER_PSIZE h = {
    0x00,
    0x05, 0x10, 0xdb, 0xd4, 0xec, 0x20, 0x1b, 0xeb, 0xe8, 0x44, 0x7d, 0x87, 0x92, 0x2f, 0x17, 0xe8, 0xab, 0xdf, 0xbf, 0xa7, 0xb7, 0xd1, 0x1d, 0x96, 0x1d, 0x71, 0x72, 0x6e, 0xf5, 0x2f, 0x03, 0xe1,
    0xc4, 0xee, 0x3d, 0x7a, 0xba, 0x33, 0x7b, 0x53, 0x0d, 0x24, 0x6f, 0xd1, 0x1f, 0xa1, 0xea, 0xa6, 0x1b, 0x1e, 0x7e, 0x2b, 0x6a, 0x70, 0x10, 0x0a, 0xcd, 0x4a, 0xfa, 0x4f, 0x57, 0x36, 0xa4, 0x5a,
    0x5a, 0x3f, 0x72, 0x41, 0x96, 0x18, 0x99, 0x0a, 0xd9, 0x69, 0xfe, 0x5f, 0x73, 0x33, 0xfc, 0x08, 0xa4, 0xad, 0x5e, 0x7d, 0xae, 0x4c, 0x33, 0x30, 0x5d, 0x04, 0xad, 0x77, 0xe1, 0x05, 0x1b, 0xfe,
    0xb9, 0x5c, 0x59, 0x6c, 0x71, 0x1d, 0xde, 0x31, 0x3f, 0x38, 0x2d, 0xbb, 0x0e, 0xd8, 0x0d, 0x34, 0xb8, 0x23, 0x1d, 0x0d, 0x16, 0x93, 0xbb, 0xf3, 0x6d, 0x24, 0x4f, 0x10, 0x8e, 0x13, 0x65, 0x66
};

NUMBER_PSIZE sigma_z_prime = {
    0x00,
    0x00, 0xff, 0x35, 0x8c, 0x26, 0xdc, 0x6f, 0x22, 0xbd, 0xc4, 0x56, 0xea, 0x41, 0x29, 0x61, 0x38, 0x50, 0xf7, 0x3c, 0x1d, 0xbd, 0x8d, 0x5a, 0xb8, 0x5f, 0x45, 0x6e, 0x4e, 0x4f, 0xf8, 0xc8, 0x65,
    0x81, 0x9c, 0x5b, 0x7b, 0x00, 0x7d, 0x61, 0xe9, 0xd2, 0x98, 0xa1, 0xb0, 0x99, 0xc5, 0xf8, 0xa0, 0x5f, 0xd4, 0xbc, 0x8e, 0x5b, 0x4c, 0x32, 0xce, 0x57, 0xc7, 0x34, 0xf0, 0x9a, 0x8e, 0x81, 0x0d,
    0x15, 0x7c, 0x35, 0x56, 0xe6, 0xd8, 0x75, 0xc4, 0xf8, 0x01, 0x72, 0x24, 0xbc, 0x97, 0xb4, 0x36, 0x5d, 0xeb, 0x66, 0x3a, 0xc4, 0xaf, 0x14, 0xe5, 0x37, 0x84, 0xad, 0x49, 0xee, 0xf5, 0x2c, 0x62,
    0xad, 0x59, 0x8f, 0x99, 0x09, 0x40, 0x6f, 0x7e, 0x58, 0x77, 0xb4, 0x33, 0x14, 0xe8, 0x7d, 0x4b, 0xa5, 0x1c, 0x0f, 0x2a, 0x9f, 0x87, 0xda, 0x83, 0xa3, 0x83, 0xf2, 0x5c, 0x3f, 0xd6, 0xf9, 0xd4
};

NUMBER_QSIZE sigma_c_prime = { 0x00, 0x29, 0xf6, 0xec, 0x34, 0x20, 0x88, 0xdc, 0x2d, 0xc9, 0x55, 0xfe, 0xfe, 0x1c, 0x19, 0x27, 0x6f, 0xd4, 0x9b, 0xe5, 0x7b };
NUMBER_QSIZE sigma_r_prime = { 0x00, 0x86, 0xcb, 0x93, 0xc0, 0x27, 0x15, 0x7f, 0xf4, 0xd4, 0x98, 0x40, 0xde, 0x80, 0x01, 0xac, 0x76, 0xd3, 0xc4, 0x8a, 0xae };

NUMBER_QSIZE UID_t = { 0x00, 0x56, 0xd4, 0xf9, 0x5e, 0x8a, 0x13, 0xc8, 0x4a, 0xbb, 0x7a, 0xa9, 0x0f, 0xb5, 0xad, 0x01, 0x31, 0xea, 0xa0, 0x3f, 0xf3 };

NUMBER_PSIZE sigma_a_prime = {
    0x00,
    0x59, 0xca, 0x47, 0x60, 0xa5, 0xa3, 0xda, 0xe9, 0xd5, 0x58, 0x4c, 0xa6, 0x44, 0x0b, 0xe4, 0x2b, 0x22, 0x9e, 0x25, 0x97, 0x33, 0x09, 0xe2, 0x6f, 0x68, 0x1e, 0xf3, 0xbd, 0x79, 0x3e, 0x63, 0x92,
    0x95, 0x4e, 0x7b, 0x9a, 0xfb, 0x88, 0x9b, 0x5d, 0x29, 0x6f, 0x05, 0x19, 0xd3, 0xec, 0x90, 0xf5, 0x13, 0xf5, 0x05, 0xae, 0xec, 0xa1, 0x54, 0x96, 0x26, 0x53, 0xd5, 0xf1, 0x98, 0xc5, 0xbf, 0xe6,
    0xa8, 0x3c, 0x79, 0x69, 0x2c, 0xb0, 0x5c, 0x5c, 0x24, 0x63, 0x37, 0xe6, 0xbc, 0xca, 0xb0, 0x8a, 0xb4, 0x15, 0x0b, 0x0e, 0xce, 0xc0, 0x7d, 0x27, 0x30, 0xda, 0xf2, 0x75, 0x24, 0xc0, 0x6f, 0xb0,
    0xa3, 0x43, 0x44, 0x53, 0x14, 0x1e, 0xb5, 0xf3, 0x54, 0xb3, 0x03, 0x00, 0xef, 0x08, 0xc4, 0xda, 0xa9, 0xff, 0x03, 0xa2, 0x77, 0x5e, 0xa3, 0x8c, 0xbc, 0xc5, 0xba, 0xf2, 0x34, 0x60, 0xcc, 0x2f
};

NUMBER_PSIZE sigma_b_prime = {
    0x00,
    0x4e, 0xbf, 0x67, 0x7e, 0x6f, 0x2b, 0x32, 0x0d, 0xe0, 0xfb, 0xaa, 0x5c, 0x81, 0x90, 0x16, 0x27, 0xc9, 0x95, 0xf1, 0x12, 0xb4, 0x7b, 0xb4, 0x51, 0x73, 0x86, 0x39, 0xc0, 0xbd, 0xf1, 0x81, 0xe3,
    0x2f, 0x3e, 0x3d, 0x18, 0x25, 0xbf, 0xcd, 0xf3, 0x91, 0x69, 0x91, 0x53, 0xac, 0xd7, 0xc5, 0x68, 0xc3, 0x9d, 0x1c, 0x25, 0xba, 0x2e, 0xc9, 0x48, 0x1b, 0xd5, 0x99, 0x66, 0x9a, 0xc8, 0x65, 0xaf,
    0xf5, 0x0d, 0x53, 0x3f, 0xb1, 0xe3, 0xea, 0x39, 0x55, 0xb0, 0xd8, 0x3b, 0x19, 0x41, 0xca, 0xba, 0x9d, 0x08, 0xee, 0xc6, 0xc2, 0x93, 0xa4, 0x63, 0xbd, 0x9c, 0xc8, 0xd2, 0x57, 0xdc, 0x95, 0xe8,
    0x69, 0x1e, 0x43, 0x98, 0xf5, 0xb1, 0x25, 0x31, 0xe9, 0x1d, 0x76, 0x7c, 0x9c, 0x81, 0x1e, 0xc3, 0x9b, 0x87, 0x7e, 0x95, 0x02, 0x08, 0xef, 0xb9, 0x1b, 0x0f, 0xff, 0x1b, 0xc7, 0xcd, 0x0f, 0xe6
};

unsigned char tempArray[TEMP_SIZE];

// Again, w_i are destroyed during protocol runs, so we need to remember the test values
NUMBER_QSIZE w_iTest[MAX_ATTR + 1] = {
    // w0:
    0x00, 0x7d, 0xfa, 0x99, 0x36, 0x4b, 0xa7, 0xb2, 0xcf, 0x01, 0x4d, 0x54, 0x71, 0x21, 0x1e, 0x1d, 0xc0, 0x58, 0x01, 0x6f, 0xad,
#if MAX_ATTR > 0
    // w1:
    0x00, 0xbe, 0x47, 0x09, 0x91, 0xd6, 0x1c, 0x19, 0x3b, 0x43, 0xdc, 0x5f, 0xea, 0xd3, 0xe3, 0xbd, 0x0e, 0x7f, 0x93, 0xbf, 0x80,
#endif
#if MAX_ATTR > 1
    // w2:
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#endif
#if MAX_ATTR > 2
    // w3:
    0x00, 0x7e, 0xbe, 0xcc, 0x2b, 0x27, 0xca, 0xc3, 0x2c, 0xe4, 0x7e, 0x57, 0xe3, 0xa2, 0x06, 0x4e, 0x75, 0xac, 0x5d, 0x57, 0x8d,
#endif
#if MAX_ATTR > 3
    // w4:
    0x00, 0xd2, 0x99, 0x72, 0x3c, 0x57, 0x45, 0x0f, 0xd7, 0x42, 0xb8, 0x3f, 0xb8, 0xa0, 0xad, 0x00, 0xe7, 0xab, 0x0e, 0xec, 0x35,
#endif
#if MAX_ATTR > 4
    // w5:
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#endif
};

#pragma melsession

// These vars will sit in RAM

typedef struct {
   NUMBER_PSIZE a;           // 129 bytes
   NUMBER_PSIZE b;           // 129 bytes
   NUMBER_QSIZE alpha;       // 21 bytes
   NUMBER_QSIZE beta1;       // 21 bytes
   NUMBER_QSIZE beta2;       // 21 bytes
                             // Total now: 321
} TEMP_SPACE;

union {
  TEMP_SPACE vars;                    // 321 bytes or
  unsigned char array[256 + 72];      // 328 bytes
} temp_ram;

unsigned char UD[MAX_ATTR]; // D-s are marked 0x01,  U-s are marked 0x00

NUMBER_QSIZE w_i[MAX_ATTR + 1] = { // 0, 1, ... n
    // w0:
    0x00, 0x7d, 0xfa, 0x99, 0x36, 0x4b, 0xa7, 0xb2, 0xcf, 0x01, 0x4d, 0x54, 0x71, 0x21, 0x1e, 0x1d, 0xc0, 0x58, 0x01, 0x6f, 0xad,
#if MAX_ATTR > 0
    // w1:
    0x00, 0xbe, 0x47, 0x09, 0x91, 0xd6, 0x1c, 0x19, 0x3b, 0x43, 0xdc, 0x5f, 0xea, 0xd3, 0xe3, 0xbd, 0x0e, 0x7f, 0x93, 0xbf, 0x80,
#endif
#if MAX_ATTR > 1
    // w2:
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#endif
#if MAX_ATTR > 2
    // w3:
    0x00, 0x7e, 0xbe, 0xcc, 0x2b, 0x27, 0xca, 0xc3, 0x2c, 0xe4, 0x7e, 0x57, 0xe3, 0xa2, 0x06, 0x4e, 0x75, 0xac, 0x5d, 0x57, 0x8d,
#endif
#if MAX_ATTR > 3
    // w4:
    0x00, 0xd2, 0x99, 0x72, 0x3c, 0x57, 0x45, 0x0f, 0xd7, 0x42, 0xb8, 0x3f, 0xb8, 0xa0, 0xad, 0x00, 0xe7, 0xab, 0x0e, 0xec, 0x35,
#endif
#if MAX_ATTR > 4
    // w5:
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#endif
};

NUMBER_QSIZE r_i[MAX_ATTR + 1] = { // 0, 1, ... n
    // r0:
    0x00, 0x0c, 0x83, 0x8c, 0x22, 0x66, 0xd9, 0x83, 0xbc, 0x89, 0x66, 0x19, 0xda, 0x2d, 0x7b, 0x36, 0x2d, 0xe0, 0x77, 0x94, 0xf8,
#if MAX_ATTR > 0
    // r1:
    0x00, 0xf4, 0xf7, 0x73, 0x1f, 0x4a, 0x2f, 0x62, 0xcb, 0xc6, 0x9e, 0x60, 0x7e, 0xba, 0xdc, 0x80, 0x1b, 0xe3, 0x75, 0x42, 0x70,
#endif
#if MAX_ATTR > 1
    // r2:
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
#endif
#if MAX_ATTR > 2
    // r3:
    0x00, 0xec, 0xd7, 0xca, 0xac, 0x67, 0x84, 0x94, 0x98, 0xbe, 0x3e, 0xaa, 0x1f, 0xe6, 0xa2, 0x2e, 0x78, 0x2f, 0x01, 0xe0, 0x60,
#endif
#if MAX_ATTR > 3
    // r4:
    0x00, 0x13, 0x4e, 0x75, 0x75, 0x44, 0x1e, 0xbe, 0x33, 0x98, 0x8e, 0x37, 0xc5, 0xd6, 0x3f, 0x8e, 0x9e, 0x52, 0x53, 0xfb, 0x7b,
#endif
#if MAX_ATTR > 4
    // r5:
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#endif
};

NUMBER_QSIZE a = { 0x00, 0xee, 0xda, 0x23, 0xce, 0xa5, 0x7b, 0x4b, 0x3d, 0x6e, 0x45, 0x6e, 0x4c, 0x0f, 0x1a, 0xec, 0x55, 0x01, 0x7f, 0x39, 0x48 };
NUMBER_QSIZE c = { 0x00, 0xbf, 0x4a, 0xfc, 0xc7, 0x13, 0x26, 0x51, 0xa3, 0xaa, 0x2a, 0x07, 0xf2, 0xca, 0x6d, 0x72, 0x49, 0x58, 0xba, 0xf0, 0xba };

NUMBER_PSIZE t;

// Safe assumption is that we have 800 bytes
// So far 294 + 328 + 129 bytes

#pragma melstatic

/**
  * This formats the first four bytes of the given array to form the provided int. int-s a really shorts in Multos...
  */ 
void putIntIntoArray(int num, unsigned char *array) {
    array[0] = array[1] = 0;
    array[2] = (num >> 8) & 0xFF;
    array[3] = (num) & 0xFF;
}

int putNumberIntoArray(int length, unsigned char *number, unsigned char *array) {
    int offset = 0;
	int i = 0;
	int skip = 0;
	int actualLength = 0;
	if(length == PSIZE_BYTES || length == QSIZE_BYTES) {
       while(number[skip] == 0x00) skip++;
	}
	actualLength = length - skip;
	putIntIntoArray(actualLength, array);
	offset += 4;
	memcpy(array + offset, number + skip, actualLength);
	offset += actualLength;
	return offset;
}

// TODO try this without hashing, perhaps would be faster
void generateRandom20Bytes(unsigned char *dest) {
   unsigned char temp[9];
   GetRandomNumber(temp);
   temp[8] = rcounter++;
   SHA1(9, dest, temp);
}

void calcGamma(void) {
   int i;
   // gamma = g_0 g_1 ^ x_1 ... g_n ^ x_n g_t ^ x_t mod p
   gamma = g_i[0];
   for(i = 1; i < MAX_ATTR + 2; i++) {
      ModExp(QSIZE_BYTES, PSIZE_BYTES, x_i[i-1].number, p.number, g_i[i].number, t.number);
      ModMul(PSIZE_BYTES, gamma.number, t.number, p.number);
   }
   debugValue("gamma", gamma.number, PSIZE_BYTES);
}

void calcSigmaZ(void) {
   int i;
   // sigma_z = z_0 z_1 ^ x_1 ... z_n ^ x_n z_t ^ x_t mod p
   sigma_z = z_i[0];
   for(i = 1; i < MAX_ATTR + 2; i++) {
      ModExp(QSIZE_BYTES, PSIZE_BYTES, x_i[i-1].number, p.number, z_i[i].number, t.number);
      ModMul(PSIZE_BYTES, sigma_z.number, t.number, p.number);
   }
   debugValue("sigma_z", sigma_z.number, PSIZE_BYTES);
}

/**
  * In normal protocol runs these numbers are randomly generated,
  * for testing purposes they are fixed to test vector values
  */
void generateRandomAlphaBeta(void) {
   if(testMode) {
        COPYN(QSIZE_BYTES+1, temp_ram.vars.alpha.number_w, alphaTest.number_w);
        COPYN(QSIZE_BYTES+1, temp_ram.vars.beta1.number_w, beta1Test.number_w);
        COPYN(QSIZE_BYTES+1, temp_ram.vars.beta2.number_w, beta2Test.number_w);
   }else{
     generateRandom20Bytes(temp_ram.vars.alpha.number);
     generateRandom20Bytes(temp_ram.vars.beta1.number);
     generateRandom20Bytes(temp_ram.vars.beta2.number);
     temp_ram.vars.alpha.number_w[0] = 0;
     temp_ram.vars.beta1.number_w[0] = 0;
     temp_ram.vars.beta2.number_w[0] = 0;
     ModularReduction(QSIZE_BYTES, QSIZE_BYTES, temp_ram.vars.alpha.number, q.number);
     ModularReduction(QSIZE_BYTES, QSIZE_BYTES, temp_ram.vars.beta1.number, q.number);
     ModularReduction(QSIZE_BYTES, QSIZE_BYTES, temp_ram.vars.beta2.number, q.number);
   }
   debugValue("alpha", temp_ram.vars.alpha.number, QSIZE_BYTES);
   debugValue("beta1", temp_ram.vars.beta1.number, QSIZE_BYTES);
   debugValue("beta2", temp_ram.vars.beta2.number, QSIZE_BYTES);
   
}

void computeXt(void) {
   int i;
   int offset = 0;
   
   offset += putNumberIntoArray(UID_p_length, UID_p, tempArray+offset);
   offset += putNumberIntoArray(PSIZE_BYTES, p.number, tempArray+offset);
   offset += putNumberIntoArray(QSIZE_BYTES, q.number, tempArray+offset);
   offset += putNumberIntoArray(PSIZE_BYTES, g.number, tempArray+offset);
   putIntIntoArray(MAX_ATTR+2, tempArray+offset); offset += 4;
   for(i=0;i<MAX_ATTR+2;i++) {
       offset += putNumberIntoArray(PSIZE_BYTES, g_i[i].number, tempArray+offset);
   }   
   putIntIntoArray(MAX_ATTR, tempArray+offset); offset += 4;
   for(i=0;i<MAX_ATTR;i++) {
       tempArray[offset++] = e_i[i];
   }   
   offset += putNumberIntoArray(S_length, S, tempArray+offset);
   //debugValue("P before", tempArray, offset);   
   SHA1(offset, t.number, tempArray);
   debugValue("P", t.number, QSIZE_BYTES);
   offset = 0;
   temp_ram.array[offset++] = 0x01;
   offset += putNumberIntoArray(QSIZE_BYTES, t.number, temp_ram.array+offset);
   offset += putNumberIntoArray(TI_length, TI, temp_ram.array+offset);
   SHA1(offset, x_i[MAX_ATTR].number, temp_ram.array);
   ModularReduction(QSIZE_BYTES, QSIZE_BYTES, x_i[MAX_ATTR].number, q.number);
   debugValue("x_t", x_i[MAX_ATTR].number, QSIZE_BYTES);
}
	
void doPrecomputations(void) {
     generateRandomAlphaBeta();

     // h = gamma ^ alpha mod p
     ModExpSecure(QSIZE_BYTES, PSIZE_BYTES, temp_ram.vars.alpha.number, p.number, gamma.number, h.number);
     debugValue("h", h.number, PSIZE_BYTES);

     // sigma_z_prime = sigma_z ^ alpha mod p
     ModExpSecure(QSIZE_BYTES, PSIZE_BYTES, temp_ram.vars.alpha.number, p.number, sigma_z.number, sigma_z_prime.number);
     debugValue("sigma_z_prime", sigma_z_prime.number, PSIZE_BYTES);

     // t_a = g_0 ^ beta1 * g^beta2 mod p
     ModExp(QSIZE_BYTES, PSIZE_BYTES, temp_ram.vars.beta1.number, p.number, g_i[0].number, temp_ram.vars.a.number);
     ModExp(QSIZE_BYTES, PSIZE_BYTES, temp_ram.vars.beta2.number, p.number, g.number, t.number);
     ModMul(PSIZE_BYTES, temp_ram.vars.a.number, t.number, p.number);
     debugValue("t_a", temp_ram.vars.a.number, PSIZE_BYTES);
     
     // t_b = sigma_z_prime ^ beta1 * h ^ beta2 mod p
     ModExp(QSIZE_BYTES, PSIZE_BYTES, temp_ram.vars.beta1.number, p.number, sigma_z_prime.number, temp_ram.vars.b.number);
     ModExp(QSIZE_BYTES, PSIZE_BYTES, temp_ram.vars.beta2.number, p.number, h.number, t.number);
     ModMul(PSIZE_BYTES, temp_ram.vars.b.number, t.number, p.number);
     debugValue("t_b", temp_ram.vars.b.number, PSIZE_BYTES);
     
     // Compute alpha ^ -1 mod q <==> alpha ^ (q-2) mod q
     ModExpSecure(QSIZE_BYTES, QSIZE_BYTES, q_minus_2.number, q.number, temp_ram.vars.alpha.number, alphaInverse.number);
     debugValue("alphaInverse", alphaInverse.number, QSIZE_BYTES);
     
}

void sigmaACommittment(void) {
    // APDU contains sigma_a
    // sigma_a_prime = t_a * sigma_a mod p
    COPYN(PSIZE_BYTES, sigma_a_prime.number, apdu_data.number_p_size);
    ModMul(PSIZE_BYTES, sigma_a_prime.number, temp_ram.vars.a.number, p.number);
    debugValue("sigma_a_prime", sigma_a_prime.number, PSIZE_BYTES);
}

void sigmaBCommittment(void) {
    int offset = 0;
    // APDU contains sigma_b
    // sigma_b_prime = t_b * sigma_a ^ alpha mod p
    ModExpSecure(QSIZE_BYTES, PSIZE_BYTES, temp_ram.vars.alpha.number, p.number, apdu_data.number_p_size, sigma_b_prime.number);
    ModMul(PSIZE_BYTES, sigma_b_prime.number, temp_ram.vars.b.number, p.number);
    debugValue("sigma_b_prime", sigma_b_prime.number, PSIZE_BYTES);

    // sigma_c_prime = H(h, PI, sigma_z_prime, sigma_a_prime, sigma_b_prime) mod q
   
	offset += putNumberIntoArray(PSIZE_BYTES, h.number, tempArray+offset);
	offset += putNumberIntoArray(PI_length, PI, tempArray+offset);
	offset += putNumberIntoArray(PSIZE_BYTES, sigma_z_prime.number, tempArray+offset);
	offset += putNumberIntoArray(PSIZE_BYTES, sigma_a_prime.number, tempArray+offset);
	offset += putNumberIntoArray(PSIZE_BYTES, sigma_b_prime.number, tempArray+offset);
    debugValue("tempArray", tempArray, offset);
    SHA1(offset, sigma_c_prime.number, tempArray);
    debugValue("sigma_c_prime1", sigma_c_prime.number, QSIZE_BYTES);
    ModularReduction(QSIZE_BYTES, QSIZE_BYTES, sigma_c_prime.number, q.number);
	// sigma_c_prime.number[0] = 0;
    debugValue("sigma_c_prime2", sigma_c_prime.number, QSIZE_BYTES);


    // sigma_c (tmp) = sigma_c_prime + beta_1 mod q

    ADDN(QSIZE_BYTES + 1, t.number_w, sigma_c_prime.number_w, temp_ram.vars.beta1.number_w);
    // deal with overflow, put the result back into Z_q
    if(t.number_w[0]) { t.number_w[0] = 0; ASSIGN_SUBN(QSIZE_BYTES+1, t.number_w, q.number_w); t.number_w[0] = 0; }
    debugValue("sigma_c", t.number, QSIZE_BYTES);

    COPYN(QSIZE_BYTES, apdu_data.number_q_size, t.number);
}

void computeTokenID(void) {
    int offset = 0;
    offset += putNumberIntoArray(PSIZE_BYTES, h.number, temp_ram.array+offset);
    offset += putNumberIntoArray(PSIZE_BYTES, sigma_z_prime.number, temp_ram.array+offset);
    offset += putNumberIntoArray(QSIZE_BYTES, sigma_c_prime.number, temp_ram.array+offset);
    offset += putNumberIntoArray(QSIZE_BYTES, sigma_r_prime.number, temp_ram.array+offset);
    SHA1(offset, UID_t.number, temp_ram.array);
    ModularReduction(QSIZE_BYTES, QSIZE_BYTES, UID_t.number, q.number);
    debugValue("UID_t", UID_t.number, QSIZE_BYTES);
}

int sigmaRCommittment(int verify) {
    // APDU contains sigma_r
    // tA := sigma_r
    int result = 1; // true
    t.number_w[0] = 0;
    COPYN(QSIZE_BYTES, t.number, apdu_data.number_q_size);

    // sigma_r_prime = sigma_r (tA) + beta2 mod q
    ADDN(QSIZE_BYTES + 1, sigma_r_prime.number_w, t.number_w, temp_ram.vars.beta2.number_w);
    if(sigma_r_prime.number_w[0]) { sigma_r_prime.number_w[0] = 0; ASSIGN_SUBN(QSIZE_BYTES+1, sigma_r_prime.number_w, q.number_w); sigma_r_prime.number_w[0] = 0; }
    debugValue("sigma_r_prime", sigma_r_prime.number, QSIZE_BYTES);

    computeTokenID();
    // Clear the selection of attributes
    CLEARN(MAX_ATTR, UD);
    // verify signature, make it boolean result of this function
    if(verify) {
       result = 0;
       COPYN(PSIZE_BYTES, tempArray, p.number);
	   tempArray[PSIZE_BYTES - 1] = tempArray[PSIZE_BYTES - 1] - 2;
       // tempArray has p - 2 (for modular inverse)
       COPYN(PSIZE_BYTES, tempArray+PSIZE_BYTES, g_i[0].number);
       ModMul(PSIZE_BYTES, tempArray+PSIZE_BYTES, sigma_z_prime.number, p.number);
       ModExp(PSIZE_BYTES, PSIZE_BYTES, tempArray, p.number, tempArray + PSIZE_BYTES, t.number);
       ModExp(QSIZE_BYTES, PSIZE_BYTES, sigma_c_prime.number, p.number, t.number, tempArray+PSIZE_BYTES);

       // tempArray[PSIZE_BYTES...] now contains (g_0 * sigma_z_prime)^(-sigma_c_prime) mod p
       
       COPYN(PSIZE_BYTES, t.number, g.number);
       ModMul(PSIZE_BYTES, t.number, h.number, p.number);
       ModExp(QSIZE_BYTES, PSIZE_BYTES, sigma_r_prime.number, p.number, t.number, tempArray);
       // tempArray[0...] now contains (g * h) ^ sigma_r_prime mod p

       ModMul(PSIZE_BYTES, tempArray, tempArray+PSIZE_BYTES, p.number);
       // tempArray[0...] now contains RHS of signature verification equation

       COPYN(PSIZE_BYTES, t.number, sigma_a_prime.number);
       ModMul(PSIZE_BYTES, t.number, sigma_b_prime.number, p.number);
       // t contains LHS of signature verification equation

       if(memcmp(t.number, tempArray, PSIZE_BYTES) == 0) {
          result = 1;
       }
       
    }
    return result;
}

void selectD(int len) {
    int i = 0;
    int j = 0;
    CLEARN(MAX_ATTR, UD);
    for(i = 0; i < len; i++) {
      j = apdu_data.D_data[i] - 1;
      if(j < 0 || j >= MAX_ATTR) {
         ExitSW(ERR_WRONGDATA);
      }
      UD[j] = 0x01;
    }
    debugValue("UD", UD, MAX_ATTR);
}

void generateRandomWi(void) {
   int i = 0;
   if(testMode) {
     // Use the fixed test data
     COPYN((QSIZE_BYTES+1)*(MAX_ATTR+1), w_i[0].number_w, w_iTest[0].number_w);
   }else{
     CLEARN((QSIZE_BYTES+1)*(MAX_ATTR+1), w_i[0].number_w);
     // generate w_i, i = 0, 1, ..., n
     for(i = 0; i < MAX_ATTR + 1; i++) {
        if(i != 0) {
           if(UD[i-1]) continue;   // i is in D, not interested
        }
		generateRandom20Bytes(w_i[i].number);
        w_i[i].number_w[0] = 0;
        ModularReduction(QSIZE_BYTES, QSIZE_BYTES, w_i[i].number, q.number);
     }
   }
#ifdef SIMULATOR
   for(i = 0; i < MAX_ATTR + 1; i++) {
      debugValue("w_i", w_i[i].number, QSIZE_BYTES);
   }
#endif
}

void generateChallengeC(void) {
   int i;
   int D_length = 0;
   int offset = 0;
   // apdu_data contains challenge m
   debugValue("m", apdu_data.raw_data, Lc);
   // Put [D] into buffer
   offset = 4;
   for(i=0;i<MAX_ATTR;i++) {
     if(UD[i]) {
       D_length++;
       putIntIntoArray(i+1, temp_ram.array+offset);
       offset += 4;
     }
   }
   putIntIntoArray(D_length, temp_ram.array);
   // put [f_1,...,f_n] into buffer
   putIntIntoArray(MAX_ATTR, temp_ram.array + offset);
   offset += 4;
   for(i=0;i<MAX_ATTR;i++) {
     if(UD[i]) {
       offset += putNumberIntoArray(QSIZE_BYTES, x_i[i].number, temp_ram.array+offset);
     }else{
       putIntIntoArray(0, temp_ram.array + offset);
       offset += 4;
     }
   }
   // Here max bytes is 148
   debugValue("F before H()", temp_ram.array, offset);
   // t.number holds F
   SHA1(offset, t.number, temp_ram.array);
   debugValue("F", t.number, QSIZE_BYTES);

   offset = 0;
   offset += putNumberIntoArray(QSIZE_BYTES, UID_t.number, temp_ram.array+offset);
   offset += putNumberIntoArray(QSIZE_BYTES, a.number, temp_ram.array+offset);
   offset += putNumberIntoArray(Lc, apdu_data.raw_data, temp_ram.array+offset);
   offset += putNumberIntoArray(QSIZE_BYTES, t.number, temp_ram.array+offset);
   SHA1(offset, c.number, temp_ram.array);
   ModularReduction(QSIZE_BYTES, QSIZE_BYTES, c.number, q.number);
   c.number_w[0] = 0;
   debugValue("c", c.number, QSIZE_BYTES);
}

void challengeM(void) {
    int i=0;
    int offset = 0;
    generateRandomWi();    
    // Calculate a 
    ModExp(QSIZE_BYTES, PSIZE_BYTES, w_i[0].number, p.number, h.number, t.number);
    for(i = 0; i < MAX_ATTR; i++) {
       if(UD[i]) continue; // i is in D, not interested
       ModExp(QSIZE_BYTES, PSIZE_BYTES, w_i[i+1].number, p.number, g_i[i+1].number, temp_ram.vars.a.number);
       ModMul(PSIZE_BYTES, t.number, temp_ram.vars.a.number, p.number);
    }
    // t now contains h^w_0 * prod i in U g_i^w_i mod p
    offset += putNumberIntoArray(PSIZE_BYTES, t.number, temp_ram.array+offset);
    // a := H(t)
    SHA1(offset, a.number, temp_ram.array);
    ModularReduction(QSIZE_BYTES, QSIZE_BYTES, a.number, q.number);
    debugValue("a", a.number, QSIZE_BYTES);
    generateChallengeC();

    // compute r_i i = 0
    COPYN(QSIZE_BYTES+1, t.number_w, c.number_w);
    ModMul(QSIZE_BYTES, t.number, alphaInverse.number, q.number);
    ADDN(QSIZE_BYTES + 1, r_i[0].number_w, t.number_w, w_i[0].number_w);
    if(r_i[0].number_w[0]) { r_i[0].number_w[0] = 0; ASSIGN_SUBN(QSIZE_BYTES+1, r_i[0].number_w, q.number_w); r_i[0].number_w[0] = 0; }
    debugValue("r_i", r_i[0].number, QSIZE_BYTES);

    // compute r_i i = 1,..., n i in U
    for(i = 0; i < MAX_ATTR; i++) {
       if(UD[i]) continue; // i is in D, not interested
       COPYN(QSIZE_BYTES+1, t.number_w, c.number_w);
       COPYN(QSIZE_BYTES+1, w_i[0].number_w, w_i[i+1].number_w);
       ModMul(QSIZE_BYTES, t.number, x_i[i].number, q.number);
       SUBN(QSIZE_BYTES + 1, temp_ram.array, w_i[0].number_w, t.number_w);
       if(temp_ram.array[0]) { temp_ram.array[0] = 0; ASSIGN_ADDN(QSIZE_BYTES+1, temp_ram.array, q.number_w); temp_ram.array[0] = 0; }
       COPYN(QSIZE_BYTES+1, r_i[i+1].number_w, temp_ram.array);       
       debugValue("r_i", r_i[i+1].number, QSIZE_BYTES);
    }       

    // Send a back
    COPYN(QSIZE_BYTES, apdu_data.number_q_size, a.number);
    // clear w_i
    CLEARN((QSIZE_BYTES+1)*(MAX_ATTR+1), w_i[0].number_w);
}

/**
    Index is already counted from 0..n-1
  */
int discloseAi(int index) {
    int i = 0;
	memcpy(apdu_data.raw_data, A_i[index].attr_val, A_i[index].attr_size);
	return A_i[index].attr_size;
}

void returnRi(int index) {
    COPYN(QSIZE_BYTES, apdu_data.number_q_size, r_i[index].number);
}

/**
     index == 0 -> h (P size)
     index == 1 -> sigma_z_prime (P size)
     index == 2 -> sigma_c_prime (Q size)
     index == 3 -> sigma_r_prime (Q size)
  */
void returnSigmas(int index) {

    CLEARN(MAX_ATTR, UD);
    if(index == 0) {
       COPYN(PSIZE_BYTES, apdu_data.number_p_size, h.number);
    }else if (index == 1) {
       COPYN(PSIZE_BYTES, apdu_data.number_p_size, sigma_z_prime.number);
    }else if (index == 2) {
       COPYN(QSIZE_BYTES, apdu_data.number_q_size, sigma_c_prime.number);
    }else if (index == 3) {
       COPYN(QSIZE_BYTES, apdu_data.number_q_size, sigma_r_prime.number);
    }
}

void main(void)
{
  int i = 0;
  //int j = 0;
  if (CLA != UPROVE_CLA)
    ExitSW(ERR_WRONGCLASS);
  
  switch (INS)
    {

    /** INITIALIZATION/SETTER/GETTER COMMANDS **/ 

    case CMD_INIT_SET_NOT:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      ExitSW(ERR_INS_NOT_SUPPORTED);
      break;

    case CMD_INIT_GET_NOT:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      apdu_data.raw_data[0] = 0x01;
      ExitLa(1);
      break;

    case CMD_INIT_SET_UIDP:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
	  memcpy(UID_p, apdu_data.raw_data, Lc);
      UID_p_length = Lc;
	  debugValue("UID_p", UID_p, UID_p_length);
      ExitLa(0);
      break;

    case CMD_INIT_GET_UIDP:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      memcpy(apdu_data.raw_data, UID_p, UID_p_length);
      ExitLa(UID_p_length);
      break;

    case CMD_INIT_SET_PQG:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      switch(P1) {
          case 0: // p
            if (Lc != PSIZE_BYTES) ExitSW(ERR_WRONGLENGTH);
            COPYN(PSIZE_BYTES, p.number, apdu_data.number_p_size);
		    debugValue("p", p.number, PSIZE_BYTES);
            break;
          case 1: // q
            if (Lc != QSIZE_BYTES) ExitSW(ERR_WRONGLENGTH);
            COPYN(QSIZE_BYTES, q.number, apdu_data.number_q_size);
            COPYN(QSIZE_BYTES, q_minus_2.number, apdu_data.number_q_size);
            // FIXME This is not bulletproof:
            q_minus_2.number[QSIZE_BYTES - 1] = q_minus_2.number[QSIZE_BYTES - 1] - 2;
		    debugValue("q", q.number, QSIZE_BYTES);
		    debugValue("q-2", q_minus_2.number, QSIZE_BYTES);
            break;
          case 2: // g
            if (Lc != PSIZE_BYTES) ExitSW(ERR_WRONGLENGTH);
            COPYN(PSIZE_BYTES, g.number, apdu_data.number_p_size);
		    debugValue("g", g.number, PSIZE_BYTES);
            break;
          default:
            ExitSW(ERR_WRONGP1P2);
            break;
      }
      ExitLa(0);
      break;

    case CMD_INIT_GET_PQG:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      i = PSIZE_BYTES;
      switch(P1) {
          case 0: // p
            COPYN(PSIZE_BYTES, apdu_data.number_p_size, p.number);
            break;
          case 1: // q
            COPYN(QSIZE_BYTES, apdu_data.number_q_size, q.number);
            i = QSIZE_BYTES;
            break;
          case 2: // g
            COPYN(PSIZE_BYTES, apdu_data.number_p_size, g.number);
            break;
          default:
            ExitSW(ERR_WRONGP1P2);
            break;
      }
      ExitLa(i);
      break;

    case CMD_INIT_SET_UIDH:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      ExitSW(ERR_INS_NOT_SUPPORTED);
      break;

    case CMD_INIT_GET_UIDH:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      COPYN(UID_H_length, apdu_data.raw_data, UID_H);
      ExitLa(UID_H_length);
      break;

    case CMD_INIT_SET_PUBKEY:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (P2 != MAX_ATTR + 2) ExitSW(ERR_WRONGP1P2);
      if (P1 >= P2) ExitSW(ERR_WRONGP1P2);
      if (Lc != PSIZE_BYTES) ExitSW(ERR_WRONGLENGTH);
      COPYN(PSIZE_BYTES, g_i[P1].number, apdu_data.number_p_size);
      g_i[P1].number_w[0] = 0;
      debugValue("g_i", g_i[P1].number, PSIZE_BYTES);
      ExitLa(0);
      break;

    case CMD_INIT_GET_PUBKEY:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P2 != MAX_ATTR + 2) ExitSW(ERR_WRONGP1P2);
      if (P1 >= P2) ExitSW(ERR_WRONGP1P2);
      COPYN(PSIZE_BYTES, apdu_data.number_p_size, g_i[P1].number);
      ExitLa(PSIZE_BYTES);
      break;

    case CMD_INIT_SET_EI:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      if (Lc != MAX_ATTR) ExitSW(ERR_WRONGLENGTH);
      COPYN(MAX_ATTR, e_i, apdu_data.raw_data);
      debugValue("e_i", e_i, MAX_ATTR);
      ExitLa(0);
      break;

    case CMD_INIT_GET_EI:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      COPYN(MAX_ATTR, apdu_data.raw_data, e_i);
      ExitLa(MAX_ATTR);
      break;

    case CMD_INIT_SET_ISSUEVAL:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (P2 != MAX_ATTR + 2) ExitSW(ERR_WRONGP1P2);
      if (P1 >= P2) ExitSW(ERR_WRONGP1P2);
      if (Lc != PSIZE_BYTES) ExitSW(ERR_WRONGLENGTH);
      COPYN(PSIZE_BYTES, z_i[P1].number, apdu_data.number_p_size);
      z_i[P1].number_w[0] = 0;
      debugValue("z_i", z_i[P1].number, PSIZE_BYTES);
      ExitLa(0);
      break;

    case CMD_INIT_GET_ISSUEVAL:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P2 != MAX_ATTR + 2) ExitSW(ERR_WRONGP1P2);
      if (P1 >= P2) ExitSW(ERR_WRONGP1P2);
      COPYN(PSIZE_BYTES, apdu_data.number_p_size, z_i[P1].number);
      ExitLa(PSIZE_BYTES);
      break;

    case CMD_INIT_SET_SPEC:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      ExitSW(ERR_INS_NOT_SUPPORTED);
      break;

    case CMD_INIT_GET_SPEC:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      COPYN(S_length, apdu_data.raw_data, S);
      ExitLa(S_length);
      break;

    case CMD_INIT_SET_RAWATTRVAL:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (P2 != MAX_ATTR) ExitSW(ERR_WRONGP1P2);
      if (P1 == 0) ExitSW(ERR_WRONGP1P2); // a_0 is not valid
      if (P1 > P2) ExitSW(ERR_WRONGP1P2);
	  COPYN(MAX_ATTR_SIZE, A_i[P1 - 1].attr_val, apdu_data.raw_data);
	  A_i[P1 - 1].attr_size = Lc;
      if (e_i[P1-1]) {
         // Hash the attribute
         i = putNumberIntoArray(Lc, apdu_data.raw_data, tempArray);
         SHA1(i, x_i[P1-1].number, tempArray);
         x_i[P1-1].number_w[0] = 0;
      }else{
         if(Lc > QSIZE_BYTES) ExitSW(ERR_WRONGLENGTH);
         for(i=0; i<QSIZE_BYTES+1; i++) {
           x_i[P1-1].number_w[i] = 0;
         }
		 memcpy(x_i[P1-1].number+QSIZE_BYTES-Lc, apdu_data.raw_data, Lc);
      }
      debugValue("x_i", x_i[P1-1].number, QSIZE_BYTES);
      ExitLa(0);
      break;

    case CMD_INIT_GET_RAWATTRVAL:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (!testMode) ExitSW(ERR_INS_NOT_SUPPORTED);
      if (P2 != MAX_ATTR) ExitSW(ERR_WRONGP1P2);
      if (P1 == 0) ExitSW(ERR_WRONGP1P2); // a_0 is not valid
      if (P1 > P2) ExitSW(ERR_WRONGP1P2);
	  memcpy(apdu_data.raw_data, A_i[P1 - 1].attr_val, A_i[P1-1].attr_size);
      ExitLa(A_i[P1 - 1].attr_size);
      break;

    case CMD_INIT_SET_TI:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      ExitSW(ERR_INS_NOT_SUPPORTED);
      break;

    case CMD_INIT_GET_TI:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      COPYN(TI_length, apdu_data.raw_data, TI);
      ExitLa(TI_length);
      break;

    case CMD_INIT_SET_PI:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      ExitSW(ERR_INS_NOT_SUPPORTED);
      break;

    case CMD_INIT_GET_PI:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      COPYN(PI_length, apdu_data.raw_data, PI);
      ExitLa(PI_length);
      break;

    case CMD_INIT_SET_ATTRVAL:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (!testMode) ExitSW(ERR_INS_NOT_SUPPORTED);
      if (P2 != MAX_ATTR + 1) ExitSW(ERR_WRONGP1P2);
      if (P1 == 0) ExitSW(ERR_WRONGP1P2); // x_0 is not valid
      if (P1 >  P2) ExitSW(ERR_WRONGP1P2);
      if (Lc != QSIZE_BYTES) ExitSW(ERR_WRONGLENGTH);
      COPYN(QSIZE_BYTES, x_i[P1-1].number, apdu_data.number_q_size);
      x_i[P1-1].number_w[0] = 0;
      debugValue("x_i", x_i[P1-1].number, QSIZE_BYTES);
      ExitLa(0);
      break;

    case CMD_INIT_GET_ATTRVAL:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (!testMode) ExitSW(ERR_INS_NOT_SUPPORTED);
      if (P2 != MAX_ATTR + 1) ExitSW(ERR_WRONGP1P2);
      if (P1 == 0) ExitSW(ERR_WRONGP1P2); // x_0 is not valid
      if (P1 > P2) ExitSW(ERR_WRONGP1P2);
      COPYN(QSIZE_BYTES, apdu_data.number_q_size, x_i[P1-1].number);
      ExitLa(QSIZE_BYTES);
      break;

    case CMD_INIT_GET_ATTRCOUNT:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2); 
      apdu_data.raw_data[0] = MAX_ATTR;
      ExitLa(1);
      break;

	case CMD_INIT_PRECOMPUTE_INPUTS:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 00) ExitSW(ERR_WRONGP1P2);
      if (P2 != 00) ExitSW(ERR_WRONGP1P2);
	  computeXt();
      calcGamma();
      calcSigmaZ();
      ExitLa(0);
      break;

    /** ISSUANCE COMMANDS **/ 

    case CMD_ISSUE_PRECOMPUTE:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 00) ExitSW(ERR_WRONGP1P2);
      if (P2 != 00) ExitSW(ERR_WRONGP1P2);
      doPrecomputations();
      ExitLa(0);
      break;

    case CMD_ISSUE_SIGMA_A:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 00) ExitSW(ERR_WRONGP1P2);
      if (P2 != 00) ExitSW(ERR_WRONGP1P2);
      if (Lc != PSIZE_BYTES) ExitSW(ERR_WRONGLENGTH);
      sigmaACommittment();
      ExitLa(0);
      break;

    case CMD_ISSUE_SIGMA_B:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 00) ExitSW(ERR_WRONGP1P2);
      if (P2 != 00) ExitSW(ERR_WRONGP1P2);
      if (Lc != PSIZE_BYTES) ExitSW(ERR_WRONGLENGTH);
      sigmaBCommittment();
      ExitLa(QSIZE_BYTES);
      break;

    case CMD_ISSUE_SIGMA_R:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (P1 > 0x01) ExitSW(ERR_WRONGP1P2);
      if (P2 != 00) ExitSW(ERR_WRONGP1P2);
      if (Lc != QSIZE_BYTES) ExitSW(ERR_WRONGLENGTH);
      if(sigmaRCommittment(P1)) {
        ExitLa(0);
      }else{
        ExitSW(ERR_WRONGSIGNATURE);
      }
      break;

    /** TOKEN/ATTRIBUTE PRESENTATION COMMANDS **/ 

    case CMD_PRESENT_SELECT_D:
      if (CheckCase(2) || CheckCase(4)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 00) ExitSW(ERR_WRONGP1P2);
      if (P2 != 00) ExitSW(ERR_WRONGP1P2);
      if(CheckCase(3)) {	  
	    if (Lc > MAX_ATTR) ExitSW(ERR_WRONGLENGTH);
	    selectD(Lc);
	  }else{
	    selectD(0);
	  }
      ExitLa(0);
      break;

    case CMD_PRESENT_CHALLENGE_M:
      if (!CheckCase(3)) ExitSW(ERR_WRONGCLASS);
      if (P1 != 0) ExitSW(ERR_WRONGP1P2);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      if (Lc == 0x00) ExitSW(ERR_WRONGLENGTH);
      challengeM();
      ExitLa(QSIZE_BYTES);
      break;

    case CMD_PRESENT_DISCLOSE_AI:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P1 == 0) ExitSW(ERR_WRONGP1P2);
      if (P1 > MAX_ATTR) ExitSW(ERR_WRONGP1P2);
      if (!UD[P1-1]) ExitSW(ERR_WRONGP1P2);
      if (P2 != MAX_ATTR) ExitSW(ERR_WRONGP1P2);
      ExitLa(discloseAi(P1-1));
      break;

    case CMD_PRESENT_RETURN_RI:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P1 > MAX_ATTR) ExitSW(ERR_WRONGP1P2);
      if (P1 != 0 && UD[P1-1]) ExitSW(ERR_WRONGP1P2);
      if (P2 != MAX_ATTR+1) ExitSW(ERR_WRONGP1P2);
      returnRi(P1);
      ExitLa(QSIZE_BYTES);
      break;

    case CMD_PRESENT_RETURN_SIGMAS:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P1 > 3) ExitSW(ERR_WRONGP1P2);
      if (P2 != 4) ExitSW(ERR_WRONGP1P2);
      returnSigmas(P1);
      if(P1 < 2) {
        ExitLa(PSIZE_BYTES);
      }else{
        ExitLa(QSIZE_BYTES);
      }
      break;
   
    /** TEST MODE MANAGEMENT */

    case CMD_TEST:
      if (!CheckCase(1)) ExitSW(ERR_WRONGCLASS);
      if (P2 != 0) ExitSW(ERR_WRONGP1P2);
      if (P1 > 2) ExitSW(ERR_WRONGP1P2); 
      if(P1 == 2) {
         // clears up absolutely all settable data
         CLEARN(PSIZE_BYTES, p.number);
         CLEARN(PSIZE_BYTES, g.number);
         CLEARN(QSIZE_BYTES, q.number);
         CLEARN(QSIZE_BYTES, q_minus_2.number);
         CLEARN((MAX_ATTR+2)*(PSIZE_BYTES+1), g_i[0].number_w);
         CLEARN((MAX_ATTR+2)*(PSIZE_BYTES+1), z_i[0].number_w);
         CLEARN((MAX_ATTR+1)*(QSIZE_BYTES+1), x_i[0].number_w);
         CLEARN(PSIZE_BYTES, gamma.number);
         CLEARN(PSIZE_BYTES, sigma_z.number);
         CLEARN(PSIZE_BYTES, h.number);
         CLEARN(PSIZE_BYTES, sigma_a_prime.number);
         CLEARN(PSIZE_BYTES, sigma_b_prime.number);
         CLEARN(PSIZE_BYTES, sigma_z_prime.number);
         CLEARN(QSIZE_BYTES, sigma_c_prime.number);
         CLEARN(QSIZE_BYTES, sigma_r_prime.number);
         CLEARN(QSIZE_BYTES, alphaInverse.number);
         CLEARN(QSIZE_BYTES, UID_t.number);
         CLEARN(MAX_ATTR, e_i);
		 memset(UID_p, 0, UID_p_length);
		 UID_p_length = 0;
		 for(i=0;i<MAX_ATTR;i++) {
		     A_i[i].attr_size = 0;			
		 }
		 CLEARN(MAX_ATTR_SIZE, A_i[0].attr_val);
		 CLEARN(MAX_ATTR_SIZE, A_i[1].attr_val);
		 CLEARN(MAX_ATTR_SIZE, A_i[2].attr_val);
		 CLEARN(MAX_ATTR_SIZE, A_i[3].attr_val);
		 CLEARN(MAX_ATTR_SIZE, A_i[4].attr_val);
      }else{
         testMode = P1;
      }
      ExitLa(0);
      break;

    default:
      ExitSW(ERR_INS_NOT_SUPPORTED);
  }

}


